name: Auto-release for accepted tickets
on:
  schedule:
    - cron: '*/10 * * * *'
  workflow_dispatch:
  push:

jobs:
  enable-automerge:
    runs-on: ubuntu-latest
    steps:
      - name: install npm packages
        run: |
          npm i axios
          npm i nodemailer

      - name: auto-release
        uses: actions/github-script@v4
        with:
          script: |
            const axios = require("axios");
            const nodemailer = require("nodemailer");
            const regex = new RegExp('LAMBDA-[0-9]+', 'gim');
            const {owner, repo} = context.repo;
            const jiraToken = Buffer.from("${{secrets.JIRA_MILOS_AUTH}}").toString('base64');

            async function updateLabelToIssue(issueKey, action, label, pullNumber) {
            try {
                  await axios.put(`https://rapid-engineering.atlassian.net/rest/api/latest/issue/${issueKey}`,
                    { "update": { "labels": [ { [action]: label } ] } },
                    { headers: { Authorization: `Basic ${jiraToken}` } }
                  );
                } catch(e) {
                  console.error(`PR #${pullNumber}: can't add label to Jira ticket ${issueKey}. ${e.message}. `);
                }
            }

            const mailer = nodemailer.createTransport({
              host: "${{secrets.SMTP_HOST}}",
              port: ${{secrets.SMTP_PORT}},
              secure: true,
              auth: {
                user: "${{secrets.SMTP_USERNAME}}",
                pass: "${{secrets.SMTP_PASSWORD}}"
              }
            });

            const pulls = (await github.pulls.list({ owner, repo, state: "open", base: "master" })).data;
            console.info(`Open PRs: ${pulls.map(p => p.number)}`);
            for (const pull of pulls) {
              const matches = pull.title.match(regex);
              if (!matches) {
                console.info(`PR #${pull.number}: title does not contain a ticket key. SKIP.`);
                continue;
              }

              const labels = await github.issues.listLabelsOnIssue({ owner, repo, issue_number: pull.number });
              if (labels.data.some(l => l.name === "no auto-release")) {
                console.info(`PR #${pull.number}: labeled with 'no auto-release'. SKIP.`);
                continue;
              }


              const issueKey = matches[0];
              const issue = (await axios.get(`https://rapid-engineering.atlassian.net/rest/api/latest/issue/${issueKey}`, {
                headers: { Authorization: `Basic ${jiraToken}` }
              })).data;

              console.info(issue);
              if (issue.fields.resolution && issue.fields.resolution.name === 'Rejected') {
                console.info(`PR #${pull.number}: ticket is Rejected. CLOSE PR.`);
                await github.pulls.update({ owner, repo, pull_number: pull.number, state: 'closed' });
                continue;
              }

              let isDependantTicketNotDeployed = true;

              for (const issueLink of issue.fields.issuelinks) {
                if (issueLink.type.outward == 'depends on' && issueLink.outwardIssue) {
                  const linkedTicketlabels = (await axios.get(`https://rapid-engineering.atlassian.net/rest/api/latest/issue/${issueLink.outwardIssue.key}?fields=code`,
                                    {headers: { Authorization: `Basic ${jiraToken}` }})).data;
                  console.info(linkedTicketlabels);

                }
              }

              if (isDependantTicketNotDeployed) {
                continue;
              }

              if (!issue.fields.resolution || issue.fields.resolution.name !== 'Accepted') {
                console.info(`PR #${pull.number}: ticket is not Accepted yet. SKIP.`);
                continue;
              }

              if ((issue.fields.customfield_10165 && issue.fields.customfield_10165.value === 'Yes') ||
                  issue.fields.issuelinks.some(l => l.type.inward === 'Previous iteration of' && l.inwardIssue)) {
                console.info(`PR #${pull.number}: ticket has next iteration (Accept&Iterate flow). SKIP.`);
                continue;
              }

              const pullData = (await github.pulls.get({ owner, repo, pull_number: pull.number })).data;
              if (pullData.mergeable && (pullData.mergeable_state === 'clean' || pullData.mergeable_state === 'unstable')) {
                console.info(`PR #${pull.number}: ticket Accepted and PR is mergeable. MERGE.`);
                try {
                  await github.pulls.merge({ owner, repo, pull_number: pull.number });
                  await updateLabelToIssue(issueKey, 'remove', 'pending-dependencies', pull.number);
                  await updateLabelToIssue(issueKey, 'add', 'auto-released', pull.number);
                  try {
                    await mailer.sendMail({
                      from: "Service User <${{secrets.MAIL_NOTIFICATION_FROM}}>",
                      to: "${{secrets.MAIL_NOTIFICATION_TO}}",
                      subject: `Scheduled to release: ${pull.title}`,
                      text: `Dear team,\n\nJIRA ticket "${pull.title}" has been scheduled to release to production.\n\nPR link: ${pull.html_url}\n\nPlease note that it will take some time to complete the deployment.`
                    });
                  } catch(e) {
                    console.error(`PR #${pull.number}: can't send notification email. ${e.message}. `);
                  }
                  continue;
                } catch(e) {
                  console.error(`PR #${pull.number}: the merge attempt failed. ${e.message}. `);
                }
              } else {
                console.info(`PR #${pull.number}: ticket Accepted but PR is not mergeable yet. SKIP.`);
              }
            }
